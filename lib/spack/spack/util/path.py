# Copyright 2013-2020 Lawrence Livermore National Security, LLC and other
# Spack Project Developers. See the top-level COPYRIGHT file for details.
#
# SPDX-License-Identifier: (Apache-2.0 OR MIT)

"""Utilities for managing paths in Spack.

TODO: this is really part of spack.config. Consolidate it.
"""
import os
import re
import getpass
import subprocess
import tempfile

import spack.paths


__all__ = [
    'substitute_config_variables',
    'substitute_path_variables',
    'canonicalize_path']

# Substitutions to perform
replacements = {
    'spack': spack.paths.prefix,
    'user': getpass.getuser(),
    'tempdir': tempfile.gettempdir(),
}

# This is intended to be longer than the part of the install path
# spack generates from the root path we give it.  Included in the
# estimate:
#
#   os-arch      ->   30
#   compiler     ->   30
#   package name ->   50   (longest is currently 47 characters)
#   version      ->   20
#   hash         ->   32
#   buffer       ->  138
#  ---------------------
#   total        ->  200
SPACK_MAX_INSTALL_PATH_LENGTH = 300
SPACK_PATH_PADDING_CHARS = 'spack_path_placeholder'
SPACK_PATH_PADDING_SIZE = len(SPACK_PATH_PADDING_CHARS)

try:
    SPACK_SYS_MAX_PATH_LENGTH = int(subprocess.check_output(
        ['getconf', 'PATH_MAX', '/']))
except (ValueError, subprocess.CalledProcessError, OSError):
    # To be safe, if we couldn't determine the max path length on
    # the system, we should pick a conservative default
    SPACK_SYS_MAX_PATH_LENGTH = 1024

compiled_substitute_matcher = re.compile(r'(\$\w+\b|\$\{\w+\})')


def substitute_config_variables(path):
    """Substitute placeholders into paths.

    Spack allows paths in configs to have some placeholders, as follows:

    - $spack     The Spack instance's prefix
    - $user      The current user's username
    - $tempdir   Default temporary directory returned by tempfile.gettempdir()

    These are substituted case-insensitively into the path, and users can
    use either ``$var`` or ``${var}`` syntax for the variables.

    """
    # Look up replacements for re.sub in the replacements dict.
    def repl(match):
        m = match.group(0).strip('${}')
        return replacements.get(m.lower(), match.group(0))

    # Replace $var or ${var}.
    return compiled_substitute_matcher.sub(repl, path)


def substitute_path_variables(path):
    """Substitute config vars, expand environment vars, expand user home."""
    path = substitute_config_variables(path)
    path = os.path.expandvars(path)
    path = os.path.expanduser(path)
    return path


def _add_computed_padding(path):
    """Subtitute in padding of os-specific length.  The intent is to leave
    SPACK_MAX_INSTALL_PATH_LENGTH characters available for parts of the
    path generated by spack.  This is to allow for not-completely-known
    lengths of things like os/arch, compiler, package name, hash length,
    etc.
    """
    m = compiled_substitute_matcher.search(path)
    if m and m.group(0).strip('${}') == 'padding':
        len_matched_part = len(m.group(0))
        # Take whatever has been computed/substituted so far and add some room
        path_len = len(path) - len_matched_part + SPACK_MAX_INSTALL_PATH_LENGTH
        needed_pad_len = SPACK_SYS_MAX_PATH_LENGTH - path_len
        num_reps = int(needed_pad_len / (SPACK_PATH_PADDING_SIZE + 1))
        extra_chars = needed_pad_len % (SPACK_PATH_PADDING_SIZE + 1)
        reps_list = [SPACK_PATH_PADDING_CHARS for i in range(num_reps)]
        reps_list.append(SPACK_PATH_PADDING_CHARS[:extra_chars])
        computed_padding = os.path.sep.join(reps_list)
        return compiled_substitute_matcher.sub(computed_padding, path)
    return path


def canonicalize_path(path):
    """Same as substitute_path_variables, but also take absolute path."""
    path = substitute_path_variables(path)
    path = os.path.abspath(path)
    path = _add_computed_padding(path)

    return path
